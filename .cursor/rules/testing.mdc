---
description: Testing conventions and patterns
globs: **/*.test.ts,**/*.test.tsx,**/*.spec.ts,**/*.spec.tsx
alwaysApply: false
---

# Testing Rules

## Test File Organization

### Location
- Co-locate test files with source files
- Name pattern: `ComponentName.test.tsx` or `utils.test.ts`
- Integration tests in `__tests__/` directory

### File Structure
```typescript
// ServiceCard.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ServiceCard } from './ServiceCard';

// Group related tests
describe('ServiceCard', () => {
  // Setup - shared test data
  const defaultProps = {
    title: 'Test Service',
    description: 'Test description',
    href: '/test',
  };

  // Basic rendering tests
  describe('rendering', () => {
    it('renders title and description', () => {
      render(<ServiceCard {...defaultProps} />);
      
      expect(screen.getByRole('heading')).toHaveTextContent('Test Service');
      expect(screen.getByText('Test description')).toBeInTheDocument();
    });
  });

  // Interaction tests
  describe('interactions', () => {
    it('navigates on click', async () => {
      const user = userEvent.setup();
      render(<ServiceCard {...defaultProps} />);
      
      const link = screen.getByRole('link');
      expect(link).toHaveAttribute('href', '/test');
    });
  });
});
```

## Test Naming

### Describe Blocks
- Component name for component tests
- Function name for utility tests
- Feature name for integration tests

### Test Names
- Start with "should" or describe expected behavior
- Be specific about what is being tested

```typescript
// ✅ Good test names
it('renders service title in heading')
it('displays error message when form validation fails')
it('calls onSubmit with form data when submitted')

// ❌ Bad test names
it('works')
it('renders correctly')
it('test 1')
```

## Component Testing

### React Testing Library
```typescript
import { render, screen, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('ContactForm', () => {
  it('submits form with valid data', async () => {
    const handleSubmit = vi.fn();
    const user = userEvent.setup();
    
    render(<ContactForm onSubmit={handleSubmit} />);
    
    // Find elements by accessible roles/labels
    await user.type(screen.getByLabelText('Namn'), 'Test User');
    await user.type(screen.getByLabelText('E-post'), 'test@example.com');
    await user.click(screen.getByRole('button', { name: /skicka/i }));
    
    expect(handleSubmit).toHaveBeenCalledWith({
      name: 'Test User',
      email: 'test@example.com',
    });
  });
});
```

### Query Priority
1. `getByRole` - accessible elements
2. `getByLabelText` - form elements
3. `getByPlaceholderText` - inputs
4. `getByText` - non-interactive elements
5. `getByTestId` - last resort

```typescript
// ✅ Prefer
screen.getByRole('button', { name: 'Submit' })
screen.getByLabelText('Email')

// ❌ Avoid
screen.getByTestId('submit-button')
document.querySelector('button')
```

## Async Testing

### Wait for Elements
```typescript
import { waitFor, findByText } from '@testing-library/react';

it('shows success message after submission', async () => {
  render(<Form />);
  
  await user.click(screen.getByRole('button', { name: 'Submit' }));
  
  // Wait for async updates
  await waitFor(() => {
    expect(screen.getByText('Success!')).toBeInTheDocument();
  });
  
  // Or use findBy (combines getBy + waitFor)
  expect(await screen.findByText('Success!')).toBeInTheDocument();
});
```

## Mocking

### Mock Functions
```typescript
import { vi } from 'vitest';

const mockFetch = vi.fn();
global.fetch = mockFetch;

beforeEach(() => {
  mockFetch.mockClear();
});

it('fetches data on mount', async () => {
  mockFetch.mockResolvedValueOnce({
    ok: true,
    json: () => Promise.resolve({ data: [] }),
  });
  
  render(<DataComponent />);
  
  expect(mockFetch).toHaveBeenCalledWith('/api/data');
});
```

### Mock Modules
```typescript
// Mock entire module
vi.mock('@/lib/prisma', () => ({
  prisma: {
    service: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
    },
  },
}));

// Mock with actual implementation
vi.mock('@/lib/utils', async () => {
  const actual = await vi.importActual('@/lib/utils');
  return {
    ...actual,
    formatCurrency: vi.fn((n) => `${n} kr`),
  };
});
```

## API Route Testing

```typescript
import { POST } from './route';
import { NextRequest } from 'next/server';

describe('POST /api/forms/submit', () => {
  it('returns 400 for invalid data', async () => {
    const request = new NextRequest('http://localhost/api/forms/submit', {
      method: 'POST',
      body: JSON.stringify({ email: 'invalid' }),
    });
    
    const response = await POST(request);
    
    expect(response.status).toBe(400);
    const body = await response.json();
    expect(body.error).toBe('Validation failed');
  });
});
```

## Utility Testing

```typescript
import { formatCurrency, slugify } from '@/lib/utils';

describe('formatCurrency', () => {
  it('formats number as SEK', () => {
    expect(formatCurrency(1000)).toBe('1 000 kr');
  });
  
  it('handles decimals', () => {
    expect(formatCurrency(99.5)).toBe('99,50 kr');
  });
});

describe('slugify', () => {
  it('converts Swedish characters', () => {
    expect(slugify('Hjärtstartare')).toBe('hjartstartare');
  });
  
  it('handles spaces and special chars', () => {
    expect(slugify('Första Hjälpen & Säkerhet')).toBe('forsta-hjalpen-sakerhet');
  });
});
```

## Test Coverage Goals
- Aim for 80%+ coverage on critical paths
- 100% coverage on utility functions
- Focus on user behavior, not implementation details
- Don't test third-party libraries
